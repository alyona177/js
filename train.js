// Задача 1. Треугольник в цикле
// Напишите цикл, который за 7 вызовов console.log
// выводит такой треугольник:
// #
// ##
// ###
// ####
// #####
// ######
// #######

let sign = '';
for (let i = 0; i <= 6; i++) {
    sign += '#';
    console.log(sign);
}

// Задача 2. FizzBuzz
// Напишите программу, которая выводит через console.log все числа от 1 до 100, с двумя исключениями. Для чисел,
// нацело делящихся на 3, она должна выводить ‘Fizz’, а для чисел, делящихся на 5 (но не на 3) – ‘Buzz’.
// Когда сумеете – исправьте её так, чтобы она выводила «FizzBuzz» для всех чисел, которые делятся и на 3, и на 5.
for (let i = 1; i <= 100; i++) {
    if (i % 3 === 0 && i % 5 !== 0) {
        console.log('Fizz');
    }
    else if (i % 5 === 0 && i % 3 !== 0) {
        console.log('Buzz');
    }

    else if (i % 5 === 0 && i % 3 === 0) {
        console.log('FizzBuzz');
    }

    else {
        console.log(i);
    }
}

// Задача 3. Шахматная доска
// Напишите программу, создающую строку, содержащую решётку 8х8, в которой линии разделяются символами
// новой строки. На каждой позиции либо пробел, либо #. В результате должна получиться шахматная доска.
// # # # #
//  # # # #
// # # # #
//  # # # #
// # # # #
//  # # # #
// # # # #
//  # # # #


for (let i = 0; i < 8; i++) {
    if (i % 2 === 0) {
        let line = "";
        for (let j = 0; j < 8; j++) {
            if (j % 2 === 0) {
                line += "#";
            }
            else {
                line += " ";
            }
        }
        console.log(line);
    }
    else {
        let line = "";
        for (let j = 0; j < 8; j++) {
            if (j % 2 === 0) {
                line += " ";
            }
            else {
                line += "#";
            }
        }
        console.log(line);
    }
}
//Вопрос:Почему если изначально(в строках 54,66) не присвоить line значение, первым в консоли выводится undefined?По идее сразу после 
// объявления переменной запускается цикл for и в любом случае в зависимости от ветки в line записывается либо решетка(57) либо пробел (60).
// Undefined значит что переменная не определена, но почему она не определена если цикл должен дать ей одно из значений?(приплюсовывая один 
// из двух вариантов, которые являются строками)?

// Задача 4 Рекурсия
// Оператор % (остаток от деления) может использоваться для определения того, чётное ли число (% 2). 
// А вот ещё один способ определения:
// Ноль чётный.
// Единица нечётная.
// У любого числа N чётность такая же, как у N - 2. Напишите рекурсивную функцию isEven согласно этим
// правилам. Она должна принимать число и возвращать булевское значение.
// Потестируйте её на 50 и 75. Попробуйте задать ей -1.
// Почему она ведёт себя таким образом? Можно ли её как-то исправить?
// console.log(isEven(50)); // → true
// console.log(isEven(75)); // → false
// console.log(isEven(-1)); // → ??


function parity(x) {
    if (x !== 0 && x !== 1) {
        if (x > 0) {
            return parity(x - 2);
        }
        else {
            return parity(x + 2);
        }
    }
    else {
        if (x === 0) {
            return ('четное');
        }
        else {
            return ('нечетное');
        }
    }
}

let a = parity(50);
let b = parity(75);
let c = parity(-1);
console.log(a);
console.log(b);
console.log(c);

// Задача 5. Сумма диапазона
// Напишите функцию range, принимающую два аргумента – начало и конец диапазона – и возвращающую массив,
// который содержит все числа из него, включая начальное и конечное.
// Затем напишите функцию sum, принимающую массив чисел и возвращающую их сумму.

function range(first, last) {
    let array = [];
    for (let i = first; i <= last; i++) {
        array.push(i);
    }
    return array;
}

function sum(array10_20) {
    let summ = 0;
    for (let i = 0; i < array10_20.length; i++) {
        summ += array10_20[i];
    }
    return summ;
}

let array10_20 = range(10, 20);
let sum10_20 = sum(array10_20);
console.log(array10_20);
console.log(sum10_20);

// Задача 6. Обращаем вспять массив
// У массивов есть метод reverse, меняющий порядок элементов в массиве на обратный. В качестве
// упражнения напишите две функции, reverseArray и reverseArrayInPlace. Первая получает массив как
// аргумент и выдаёт новый массив – с обратным порядком элементов. Вторая работает как оригинальный метод 
// reverse – она меняет порядок элементов на обратный в том массиве, который был ей передан в качестве
// аргумента. Не используйте стандартный метод reverse. Если иметь в виду побочные эффекты и чистые функции, 
// какой из вариантов вам кажется более полезным? Какой более эффективным?

function reverseArray(array) {
    let reverseArray = [];
    for (let i = 0; i < array.length; i++) {
        reverseArray[i] = array[array.length - 1 - i];
    }
    return reverseArray;
}

array1 = [1, 2, 3, 4, 5];
let firstWay = reverseArray(array1);
console.log(firstWay);

function reverseArrayInPlace(array) {
    for (let i = 0; i < Math.floor(array.length / 2); i++) {
        let intermediate = array[i];
        array[i] = array[array.length - 1 - i];
        array[array.length - 1 - i] = intermediate;
    }
    return array;
}

array2 = [6, 7, 8, 9, 10, 11, 12];
let secondWay = reverseArrayInPlace(array2);
console.log(secondWay);

//Если честно, нет идей по поводу эффективности того или иного способа. Мне как человеку который писал код, первый вариант
// кажется более простым, понятным, воспринимается лучше. Кажется побочных эффектов нет, а термин "чистые функции" не очень понятен.
// Под эффективностью понимается скорость выполнения запроса? Чисто интуитивно опять же кажется первый способ быстрее, состоит из 
// меньшего количества действий. 
// Антон, подскажи, как правильно было бы ответить на вопросы в задаче

// Задача 7. Список
// Объекты могут быть использованы для построения различных структур данных. Часто встречающаяся
// структура – список (не путайте с массивом). Список – связанный набор объектов, где первый объект содержит
// ссылку на второй, второй – на третий, и т.п. Напишите функцию arrayToList, которая строит такую
// структуру, получая в качестве аргумента [1, 2, 3], а также функцию listToArray, которая создаёт массив из списка.
// Также напишите вспомогательную функцию prepend, которая получает элемент и создаёт новый список, где этот элемент добавлен спереди к 
// первоначальному списку, и функцию nth, которая в качестве аргументов принимает список и число, а возвращает элемент на
// заданной позиции в списке или же undefined в случае отсутствия такого элемента.
// Если ваша версия nth не рекурсивна, тогда напишите её рекурсивную версию.
